# Справяне с грешки в Rust

## Основни теми

### Конвертиране -- `From` и `Into`

-   Типажът `From<T>`: дефинира функция `fn from(value: T) -> Self`.
-   Ако имплементираме `From<T> for U`, автоматично се получава
    `Into<U> for T`.
-   Използват се за без­грешно преобразуване -- т.е. преобразуването не
    може да се провали.

### Преобразуване от низ -- `FromStr` и `.parse()`

``` rust
trait FromStr {
    type Err;
    fn from_str(s: &str) -> Result<Self, Self::Err>;
}
```

-   Методът `.parse::<F>()` върху `&str` е генеричен по `F: FromStr`.
-   Така можем да конвертираме низ към число или собствен тип -- и ако
    не успее, получаваме `Err`.
-   Пример:

``` rust
"-13".parse::<i32>()  // Ok(-13)
"323".parse::<u8>()   // Err(ParseIntError { … })
```

### Типовете на грешки и „невъзможни" грешки

-   Ако преобразуването винаги ще успее, можем да използваме тип грешка
    `()` или по‑добре `std::convert::Infallible`.
-   Типът „never" (`!`) или празен enum `enum Never {}` се използва,
    когато стойност не може да съществува.

### Обработка на грешки -- `Result<T, E>`

-   Пример: `File::open(path)` връща `Result<File, io::Error>`.
-   Основни подходи:
    -   `match` върху резултата (`Ok` vs `Err`)
    -   Използване на помощни функции като `unwrap()` или `expect()`

### Съединяване на грешки с различен тип -- `From` + собствен тип грешка

``` rust
enum FancyError {
    Io(io::Error),
    Parse(num::ParseIntError),
}

impl From<io::Error> for FancyError { /* ... */ }
impl From<num::ParseIntError> for FancyError { /* ... */ }
```

-   Така можем в функции с `-> Result<…, FancyError>` да използваме `?`
    и грешките се „превръщат" автоматично чрез `From`.

### Помощни макроси и синтактични улеснения

``` rust
macro_rules! try_ {
    ($expr:expr) => {
        match $expr {
            Ok(result) => result,
            Err(e) => return Err(e.into()),
        }
    }
}
```

-   Съвременен стил използва оператора `?` вместо `match` или макро.

## Практически съвети и важни моменти

-   Винаги третирайте `Result`, защото има предупреждение
    `unused_must_use`.
-   Използвайте `FromStr` и `.parse()` за безопасно преобразуване.
-   Използвайте `From`/`Into` когато преобразуването е сигурно.
-   Когато функцията може да върне различни грешки, създайте собствен
    `enum Error` и имплементирайте `From`.
-   Използвайте `?` за чист и ясен код.
-   За „невъзможни" грешки използвайте `Infallible` или `!`.
